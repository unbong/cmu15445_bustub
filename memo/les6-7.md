# 6 Memory Management
* Buffer Pool Manager
* Frame； 内存中的缓冲区被组织为一个固定大小的数组区域，其中每个条目被称为Frame
* 当数据库请求一个页时，一个页的复制品会被放置在那些帧中
* 脏页是在内存中被修改过，但是尚未被反映到磁盘的帧
* 页表是持续追踪页在内存中状态。
    * 同时维护着脏页指示器与Pin（被引用计数）的元数据状态

* Lock与Latche
    * 锁在DBMS中的语义为，用来保护逻辑层内容，防止其他事务的修改
    * 在事务期间存在
    * 需要能够回滚更改
    * ！！！！！！！
    * latched是保护数据库关键区域的状态，并防止其他线程的干扰 
    * 可以理解为操作系统中的互斥锁

* Page Table与Page Directory

* 分配策略
    * 全局策略-- 为所有活动查询做出决策
        
    * 本地策略
        * 为特定查询分配帧，而不考虑并发查询的行为
        * 仍然需要支持共享页面

* 缓存池的优化
    * 多缓存池
        * 顾名思义就是使用多个缓存池来提高效率，并降低并发连接和提高本地性
        * 多个缓存池实例
            *  实现方法
                * ObjectID
                    * 在数据存储时有一个ObjectID与pageid， slotnum一起存储，以此来判定到哪一个缓存池寻找
                * Hashing
                    * 堆pageid进行散列后选择对应的缓存池
        * 每数据库缓存池
        * 每页类缓存池
    * 预取
        * 在note文件夹的21到27中（没太看懂）
    * 扫描共享
        * 也被称为同步扫描  
            * 允许多个查询适应一个正在扫描表的游标
                * 查询语句不需要一定相同
                * 可以共享中间结果
    * 缓存池旁路 没看懂（P45 ppt）


* 缓存池替换策略
    * LRU 最近最少使用
        * 选择时间戳最早的时间缓存驱逐的策略
    
    * CLOCK 时钟
        * 循环的遍历每个每个缓存的引用位，如果引用位位1表明近期被使用过，将应用位设为0 ，并查看下一个，如果引用位0， 则将其驱逐
        
    * LRU与CLOCK在DBMS中的效率不高
        * 理由： DBMS经常需要访问之前访问过的数据，即在LRU中可能是时间戳位最早的，因此需要重新将其缓存。

    * LRU-K 
        * 追踪最近K次引用的时间戳并进行记录，比较当前时间与第k次前的时间戳之间的距离最长的缓存进行驱逐，背后的思想是。。。

    * 

# 7 Hash Tables
* 静态哈希表

* 设计时需要考虑的点
    * 散列函数
        * 
    * 散列方案
        * 当发生冲突时如何解决冲突

* Facebook的 XXhash是最好的哈希函数

* 线性探测散列
    * 当发生冲突时，将值加入到冲突点的后续的槽位中

* 罗宾汉散列

* 布谷鸟散列
    * 使用两个散列函数，当发生冲突时，冲突的两个键都再进行散列

* 可扩展散列
    * 
    * ppt P63-72
    

* 线性散列